<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>D3 TEST</title>
    <style>
    .node {
        stroke: #fff;
        stroke-width: 1.5px;
        cursor: pointer;
    }

    .link {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    .node:hover {
        stroke: #000;
        stroke-width: 3px;
    }

    .link:hover {
        stroke: #ff0000;
        stroke-width: 3px;
    }

    .highlighted {
        stroke: #ff0000;
        stroke-width: 3px;
        fill: #ffcccc !important;
    }

    .linked-highlight {
        stroke: #ff0000;
        stroke-opacity: 1;
        stroke-width: 2px;
    }
    </style>
</head>
<body>
    <div id="graph"></div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Данные графа
        const graph = {
            nodes: [
                { id: "A", group: 1 },
                { id: "B", group: 1 },
                { id: "C", group: 2 },
                { id: "D", group: 2 },
                { id: "E", group: 3 }
            ],
            links: [
                { source: "A", target: "B" },
                { source: "B", target: "C" },
                { source: "C", target: "D" },
                { source: "D", target: "E" },
                { source: "A", target: "C" },
                { source: "B", target: "E" }
            ]
        };
        const width = 800, height = 600;

        // Создание SVG
        const svg = d3.select("#graph")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Инициализация симуляции
        const simulation = d3.forceSimulation(graph.nodes)
            .force("link", d3.forceLink(graph.links).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2));

        // Создание линий (рёбра)
        const link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("class", "link")
            .attr("stroke-width", 2);

        // Создание узлов
        const node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("class", "node")
            .attr("r", 10)
            .attr("fill", d => d3.schemeCategory10[d.group])
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // Добавление подписей
        const label = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(graph.nodes)
            .enter().append("text")
            .text(d => d.id)
            .attr("font-size", 12)
            .attr("dx", 15)
            .attr("dy", 4);

        // Функции для drag&drop
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Обновление позиций при симуляции
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            label
                .attr("x", d => d.x)
                .attr("y", d => d.y);
        });

        // Функция подсветки связанных элементов
        function highlightConnected(d) {
            // Сбрасываем предыдущую подсветку
            node.classed("highlighted", false);
            link.classed("linked-highlight", false);

            // Подсвечиваем выбранный узел
            d3.select(this).classed("highlighted", true);

            // Находим связанные рёбра
            const connectedLinks = graph.links.filter(link => 
                link.source.id === d.id || link.target.id === d.id
            );

            // Подсвечиваем связанные рёбра
            link.filter(l => connectedLinks.includes(l))
                .classed("linked-highlight", true);

            // Находим связанные узлы
            const connectedNodes = [];
            connectedLinks.forEach(link => {
                if (link.source.id !== d.id) connectedNodes.push(link.source.id);
                if (link.target.id !== d.id) connectedNodes.push(link.target.id);
            });

            // Подсвечиваем связанные узлы
            node.filter(n => connectedNodes.includes(n.id))
                .classed("highlighted", true);
        }

        // Добавляем обработчики событий
        node.on("mouseover", function(event, d) {
            highlightConnected.call(this, d);
        });

        node.on("click", function(event, d) {
            // При клике фиксируем подсветку
            highlightConnected.call(this, d);
            event.stopPropagation();
        });

        // Сброс подсветки при клике на пустое место
        svg.on("click", () => {
            node.classed("highlighted", false);
            link.classed("linked-highlight", false);
        });

        // Подсветка рёбер при наведении
        link.on("mouseover", function(event, d) {
            // Сбрасываем подсветку
            node.classed("highlighted", false);
            link.classed("linked-highlight", false);

            // Подсвечиваем ребро
            d3.select(this).classed("linked-highlight", true);

            // Подсвечиваем связанные узлы
            node.filter(n => n.id === d.source.id || n.id === d.target.id)
                .classed("highlighted", true);
        });

    </script>
</body>
</html>